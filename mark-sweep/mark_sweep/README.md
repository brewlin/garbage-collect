# heaps
一个内存池，每次内存不够的时候会从系统中申请 默认 0x4000 字节的内存 追加到heaps中

且所有的heaps内存会重复利用，在标记清除算法中称为用户态堆内存,保存了所有的内存，那么
在gc的时候只需要遍历整个`heaps`就能找出待回收的内存

# roots
每次`gc_malloc`申请内存后需要将它们添加到roots上，让gc可以通过roots来标记到该对象

那么gc的时候只要是roots上的对象都不会被回收，因为它们都是可以被引用、被访问的对象
```
for(root:roots){
    //标记当前对象
    mark(root);
    //递归标记对象的引用
    for(r:children(root)){
        mark(r)
    }
}
```
# gc_malloc 从内存池中申请内存
1. 第一次申请的时候 内存池为空，需要进行新增一个堆`add_heaps`
2. 然后通过`free_list`链表来遍历找出可以满足的空间

上面第二点，因为存在查找匹配的空间，那么存在切割大内存的情况
```
//死循环 遍历
for (p = prevp->next_free; ; prevp = p, p = p->next_free) {
    //堆的内存足够
    if (p->size >= req_size) {
        //刚好满足
        if (p->size == req_size)
            /* 刚好满足 */
            // 从空闲列表上 移除当前的 堆，因为申请的大小刚好把堆消耗完了
            prevp->next_free = p->next_free;

        //没有刚好相同的空间，所以从大分块中拆分一块出来给用户
        //这里因为有拆分 所以会导致内存碎片的问题，这也是 标记清除算法的一个缺点
        //就是导致内存碎片
        else {
            //....
        }
        //新的内存 是包括了 header + mem 所以返回给 用户mem部分就可以了
        return (void *)(p+1);
    }
}
```
所以标记清除算法 存在内存碎片的情况，就是因为每次去分配一个大小合适的空间是会拆分大内存块的情况