# heaps
一个内存池，每次内存不够的时候会从系统中申请 默认 0x4000 字节的内存 追加到heaps中

且所有的heaps内存会重复利用，在标记清除算法中称为用户态堆内存,保存了所有的内存，那么
在gc的时候只需要遍历整个`heaps`就能找出待回收的内存

# roots
每次`gc_malloc`申请内存后需要将它们添加到roots上，让gc可以通过roots来标记到该对象

那么gc的时候只要是roots上的对象都不会被回收，因为它们都是可以被引用、被访问的对象
```
for(root:roots){
    //标记当前对象
    mark(root);
    //递归标记对象的引用
    for(r:children(root)){
        mark(r)
    }
}
```
# gc_malloc 从内存池中申请内存
1. 第一次申请的时候 内存池为空，需要进行新增一个堆`add_heaps`
2. 然后通过`free_list`链表来遍历找出可以满足的空间

上面第二点，因为存在查找匹配的空间，那么存在切割大内存的情况
```
//死循环 遍历
for (p = prevp->next_free; ; prevp = p, p = p->next_free) {
    //堆的内存足够
    if (p->size >= req_size) {
        //刚好满足
        if (p->size == req_size)
            /* 刚好满足 */
            // 从空闲列表上 移除当前的 堆，因为申请的大小刚好把堆消耗完了
            prevp->next_free = p->next_free;

        //没有刚好相同的空间，所以从大分块中拆分一块出来给用户
        //这里因为有拆分 所以会导致内存碎片的问题，这也是 标记清除算法的一个缺点
        //就是导致内存碎片
        else {
            //....
        }
        //新的内存 是包括了 header + mem 所以返回给 用户mem部分就可以了
        return (void *)(p+1);
    }
}
```
所以标记清除算法 存在内存碎片的情况，就是因为每次去分配一个大小合适的空间是会拆分大内存块的情况

# best-fit & first-fit & worst-fit
best-ft 
```asciidoc
当gc_malloc 申请一块内存时 回去遍历空闲列表找出刚好满足的那块内存
这样做当然减少了内存碎片，但是时间方面比较浪费
```

first-fit
```asciidoc
也就是当前demo采用的方法，当从空闲列表上找到第一块满"test%d\n"的内存块，也许是大内存块
不要紧直接切割分配即可，也许会增加内存碎片，但是减少了分配时间，也是不错的方法
```

worst-fit
```asciidoc
每次都去寻找最大的内存块 然后切割分配，增加了内存碎片 时间也不咋地，所以避免使用这种
```

# 内存碎片
实际内存空间够，但是因为不连续导致分配失败，可能需要开辟新空间
![image](18504301CD8944808FF3BDC90A5E2EDD)

# [mark_sweep](./mark_sweep)
基础标记 清除算法

# [multi_free_list](../mark-sweep_multi_free_list)
为了优化分配内存速度，增加了多个空闲链表的设计
```
一般都是按字节内存 以8 对齐，所以基本只会使用 8 16 。。
list free_list[100]

free_list[1] 表示该链表指向的数据都是 1个字节的内存
free_list[2] 表示该链表指向的数据都是 2个字节的内存
.....
```
通过降低分配内存的查找时间 优化分配速度